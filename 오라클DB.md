# 데이터베이스

## 데이터와 데이터베이스, DBMS

### 데이터와 정보

데이터베이스 분야에서 데이터와 정보는 서로 다른 의미로 해석한다.

```
A카드사는 최근 몇 년간 급증한 커피 소비 동향을 파악하기 위해 A카드사에서 발급한 카드를 사용한 커피 전문점 결제 내역을 성별과 나이 대별로 분류하였다.

이 분류 작업과 관련하여 A카드사는 커피 전문점 결제 분포에서 20대 또는 30대 여성이 압도적으로 우위에 있을 것이라 예상했다.

그러나 결과는 뜻밖이었다. 커피 전문점 결제 분포의 최상위 순위를 30~40대 남성이 차지하고 있었던 것이다. 20~30대 여성의 결제 비율을 가볍게 넘어설 정도의 차이가 벌어진 것은 아니지만 예상을 뒤집는 결과였다.
```

여기서 데이터는 A카드사에서 발급한 카드를 사용한 커피 전문점 결제 내역이고, 정보는 커피 전문점 결제 분포의 최상위 순위를 30~40대 남성이 차지했다는 결과라고 볼 수 있다.

즉 데이터는 어떤 필요에 의해 수집했지만 아직 특정 목적을 위해 평가하거나 정제하지 않은 값이나 사실 또는 자료 자체를 의미한다. 그리고 정보는 수집한 데이터를 어떠한 목적을 위해 분석하거나 가공하여 가치를 추가하거나 새로운 의미를 이끌어 낼 수 있는 결과로 볼 수 있다.

'잘 수집된 데이터를 분석하고 가공하면 새로운 가치를 만들어 낼 수 있는 정보를 얻을 수 있다.'

### 효율적인 데이터 관리를 위한 조건

* 데이터를 통합하여 관리
* 일관된 방법으로 관리
* 데이터 누락 및 중복 제거
* 여러 사용자(응용 프로그램 포함)가 공동으로 실시간 사용 가능

위 조건을 만족하면서

* 특정 목적을 위해 여러 사람이 공유하여 사용할 수 있으며,
* 효율적인 관리와 검색을 위해 구조화한 데이터의 집합

을 데이터베이스라고 한다.

### 파일 시스템과 DBMS

#### 파일 시스템을 통한 데이터 관리

파일 시스템은 서로 다른 여러 응용 프로그램이 제공하는 기능에 맞게 필요한 데이터를 각각 저장하고 관리한다. 따라서 각 파일에 저장한 데이터는 서로 연관이 없고 중복 또는 누락이 발생할 수 있다.

다음 예를 통해 파일 시스템 방식으로 여러 응용 프로그램들이 각자 데이터를 관리하면 어떤 문제점이 있는지 살펴본다. 어떤 대학에 학사 프로그램과 장학금 신청 프로그램이 있다고 가정한다. 이 두 프로그램은 학생의 졸업 여부에 관련된 데이터를 각 파일에 저장하고 있다. 만약 이수선 학생이 학사 프로그램에는 졸업생으로 등록되어 있지만 장학금 신청 프로그램에서는 졸업했다는 내용이 누락되어 있다면, 실제로 졸업생으로 분류된 학생도 장학금을 신청할 수 있는 상황이 발생할 수 있다.

**학사 프로그램**

| 학번           | 이름       | 학과             | 학년  | 학기  | 상태     |
| -------------- | ---------- | ---------------- | ----- | ----- | -------- |
| 2018-00001     | 홍길동     | 철학과           | 1     | 2     | 군휴학   |
| **2018-00002** | **이수선** | **컴퓨터공학과** | **4** | **2** | **졸업** |
| 2018-00003     | 이지수     | 경영학과         | 2     | 1     | 재학     |
| 2018-00004     | 김연아     | 사회체육학과     | 3     | 1     | 휴학     |

**장학금 신청 프로그램**

| 신청 장학금 종류 | 신청 일자    | 학번           | 재학 상태 | 장학금 신청 가능 여부 |
| ---------------- | ------------ | -------------- | --------- | --------------------- |
| 국가             | 20180409     | 2018-00001     | 군 휴학   | 신청 불가             |
| **성적**         | **20180310** | **2018-00002** | **재학**  | **신청 가능**         |
| 동문             | 20180223     | 2018-00003     | 재학      | 신청 가능             |
| 근로             | 20180213     | 2018-00004     | 휴학      | 신청 불가             |

이러한 현생은 학생의 재학 상태를 관리하는 데이터가 각 응용 프로그램별로 흩어져 있기 때문에 발생한다. 따라서 학생과 관련된 일련의 데이터를 한곳에 모아 관리하고, 이렇게 한곳에 모아둔 데이터를 각각의 응용프로그램이 함께 사용하면 응용 프로그램별로 데이터를 직접 관리할 때 발생할 수 있는 데이터의 오류, 누락, 중복 등의 문제를 해결할 수 있다. 이렇게 여러 응용 프로그램이 사용할 데이터를 한곳에서 관리하기 위해 데이터베이스를 활용합니다.

**서비스의 역할 분담**

> 앞에서 본 학사 프로그램이나 장학금 신청 프로그램과 같은 모든 응용 프로그램의 목적은 특정 서비스를 제공하는 것이다. 그런데 시간이 흐름에 따라 점점 거대해지고 복잡해지는 데이터를 각각의 응용 프로그램이 직접 관리한다면 데이터 관리에 소모되는 시간과 자원 또한 점점 증가하게 된다. 또 각 데이터 간의 불일치로 인한 오류 발생 확률도 높아진다. 이는 본래 의도한 기능, 즉 특정 서비스를 제공하는 효율과 질을 떨어뜨리는 원인이 된다.
>
> 이러한 문제를 방지하기 위해서는 하나의 서비스를 처리하는 데 역할 분담이 필요하다. 역할 분담의 중요성은 주문과 배달 서비스를 생각해 보면 간단히 알 수 있다. 고객이 음식을 주문하면 음식을 주문받는 역할, 음식을 만드는 역할, 고객에게 음식을 바달하는 역할로 나뉘어 서비스가 진행됩니다. 주문이 그리 많지 않을 때에는 주문 처리, 음식 만들기, 음식 배달 과정을 한 사람이 맡을 수 있다. 하지만 많은 주문을 처리하기 위해서는 각각의 역할을 분리하여 담당하는 것이 효율적이다. 즉 서비스 요청을 받는 영역, 서비스 처리에 필요한 데이터를 다루는 영역, 처리한 데이터를 제공하는 영역으로 나누는 것이다.
>
> 앞에서 살펴본 학사 프로그램에서 역할을 나눠 본다면 학생의 재학 생태를 포함한 여러 정보의 저장을 전담하는 데이터 영역과 그 데이터를 활용하는 서비스 영역으로 나눌 수 있다. 이렇게 역할 분담을 하면 데이터 누락이나 중복 등으로 생기는 오류를 방지할 수 있다.

**DBMS를 통한 데이터 관리**

효율적인 데이터 관리 조건을 만족하며 서비스 제공의 효율성을 높이기 위해 데이터베이스 관리 시스템이 등장했다. 데이터베이스 관리 시스템은 데이터베이스의 데이터 조작과 관리를 극대화한 시스템 소프트웨어이다.

데이터베이스 관리 시스템은 보통 DBMS라고 부르며, 실무에서는 데이터베이스와 데이터베이스 관리 시스템을 따로 구별하지 않고 DB라고 부른다.

데이터베이스를 통한 데이터 관리란 여러 목적으로 사용할 데이터의 접근, 관리 등의 업무를 DBMS가 전담하는 방식을 말한다. 다시 말해 응용 프로그램이 필요한 데이터 작업을 DBMS에 요청하면, DBMS는 자신이 관리하는 데이터베이스로 관련 작업을 수행하고 결과값을 제공한다.

**응용 프로그램** ↔ **DBMS** ↔ **데이터베이스**

이러한 작업 영역의 분리는 응용 프로그램의 서비스 제공과 데이터 관련 작업 효율을 높인다. 또한 여러 응용 프로그램이 하나의 통합된 데이터를 같은 방식으로 사용, 관리할 수 있으므로 데이터 누락이나 중복을 방지할 수 있다.

DBMS는 다음 표와 같이 파일 시스템 기반 방식의 문제를 해결하면서 데이터 관리의 패러다임을 바꾸었다.

| 파일 시스템 방식의 문제                                      | DBMS를 통한 데이터 관리                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 데이터 중복                                                  | 하나의 소프트웨어가 데이터를 관리하므로 데이터 중복을 피할 수 있음 |
| 응용 프로그램이 개별 데이터를 직접 관리                      | 여러 응용 프로그램이 하나의 DBMS를 통해 데이터를 사용하므로 데이터를 동시에 공유할 수 있음 |
| 응용 프로그램이 데이터를 쓰는 방식이 각각 다름               | 하나의 DBMS를 통해 데이터를 관리하기 때문에 각각의 응용 프로그램이 데이터를 관리하는 방식이 통합됨 |
| 데이터가 특정 응용 프로그램에 종속되어 있으므로 응용 프로그램을 변경하면 기존 데이터를 사용할 수 없음 | 응용 프로그램과는 별도로 데이터가 DBMS에 의해 관리, 보관되기 때문에 응용 프로그램의 업데이트 또는 변경과 관계없이 데이터를 사용할 수 있음 |

**데이터베이스 용어의 등장과 최초의 DBMS**

> 데이터베이스라는 용어는 1963년 SDC(System Development Corporation)에서 개최한 'Development and Management of Computer-Center DataBases' 심포지엄 제목에서 처음 사용되었다. 최초의 DBMS는 제너럴 일렉트릭 사의 찰스 바흐만이 1963년에 만든 IDS(Integrated Data Store)로서 데이터베이스 개념을 확립한 소프트웨어라고 할 수 있다.

## 데이터 모델

데이터 모델이란 컴퓨터에 데이터를 저장하는 방식을 정의해 놓은 개념 모형이다. 대표 데이터 모델에는 계층형, 네트워크형, 관계형, 객체 지향형 등이 있다.

### 계층형 데이터 모델과 네트워크형 데이터 모델

계층형 데이터 모델과 네트워크형 데이터 모델은 1960년대 말부터 1980년대 말가지 상업용 데이터베이스 시장에서 많이 사용한 데이터 모델이다.

**계층형 데이터 모델**

계층형 데이터 모델은 나뭇가지 형태의 트리 구조를 활용하여 데이터 관련성을 계층별로 나누어 부모 자식 같은 관계를 정의하고 데이터를 관리한다. 계층형 데이터 모델을 이해하기 위해서는 일대다(1:N) 관계의 데이터 구조를 파악해야 한다.

이 모델에서 데이터가 저장된 파일은 다음 그림과 같이 상위 개념에 하위 개념이 포함되어 있는 특징이 있다. 기본적으로 하나의 부모 개체가 여러 자식을 가질 수 있는 반면에 자식 개체는 여러 부모 개체를 가질 수 없다는 제약이 있다. 따라서 일대다 구조의 데이터를 표현하기에는 알맞지만 자식 개체가 여러 부모를 가진 관계는 표한할 수 없다.

**네트워크형 데이터 모델**

네트워크형 데이터 모델은 망형 데이터 모델이라고도 하며 그래프 구조를 기반으로 합니다. 다시 말해 개체 간 관계를 그래프 구조로 연결하므로 자식 개체가 여러 부모 개체를 가질 수 있다는 점에서 계층형 데이터 모델과 차이가 있다.

### 객체 지향형 데이터 모델

객체 지향형 데이터 모델은 1980년대 후반에 등장한 모델로 객체지향 프로그래밍에서 사용하는 객체 개념을 기반으로 한 데이터 모델이다. 그리고 객체 지향 프로그래밍처럼 데이터를 독립된 객체로 구성하고 관리하며 상속, 어버라이드 등 객체 지향 프로그래밍에 사용되는 기능을 활용할 수 있다.

하지만 이러한 객체 지향형 모델 개념을 완전히 데이터베이스에 적용하는 것은 쉽지 않기 때문에 이를 적용한 사용 DBMS는 많지 않다. 다만 오라클 데이터베이스와 같은 여러 DBMS 제품군이 바로 뒤에 설명할 관계형 데이터 모델을 바탕으로 객체 개념을 도입하여 '객체 관계형 DBMS'로 영역을 확장하고 있다.

### 관계형 데이터 모델

관계형 데이터 모델은 1970년 에드거 프랭크 커드가 제안한 모델로서 현대에 가장 많이 사용하는 관계형 데이터베이스의 바탕이 되는 모델이다. 관계형 데이터 모델은 다른 모델과 달리 데이터 간 관계에 초점을 둔다.

예를 들어 회상의 사원 정보와 사원이 소속된 부서 정보를 데이터로 관리하는 경우를 생각해본다. 사원 정보와 부서 정보를 하나의 묶음으로 관리하면 데이터 구조가 간단해진다. 하지만 같은 부서 사원들은 부서 정보가 중복되므로 효율적인 관리가 어려워진다. 왜냐하면 부서 이름이 바뀌면 해당 부서 사원들의 부서 정보를 일일이 찾아서 모두 변경해 주어야 하기 때문이다.

따라서 관계형 데이터 모델에서는 각 데이터의 독립 특성만을 규정하여 데이터 묶음을 나눈다. 그리고 중복이 발생할 수 있는 데이터는 별개의 릴레이션으로 정의한 후 사원 정보에 소속된 부서를 식별하는 '부서 코드'를 포함하여 사원 정보 데이터와 부서 정보 데이터를 연결하는 것이다.

관계형 데이터 모델에서는 이렇게 데이터를 일정 기준으로 나누어 관리한다. 이를 위해 다양한 개념과 여러 구성 요소가 존재한다. 다음은 관계형 데이터 모델의 핵심 구성 요소를 간단히 표로 정리한 내용이다.

| 이름               | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| 개체(entity)       | 데이터베이스에서 데이터화하려는 사물, 개념의 정보 단위이다. 관계형 데이터베이스의 테이블(table) 개념과 대응되며 테이블은 릴레이션(relation)으로 표기하기도 한다. |
| 속성(attribute)    | 개체를 구성하는 데이터의 가장 작은 논리적 단위로서 데이터의 종류, 특성, 상태 등을 정의한다. 관계형 데이터베이스의 열(column) 개념과 대응된다. |
| 관계(relationship) | 개체와 개체 또는 속성 간의 연관성을 나타내기 위해 사용한다. 관계형 데이터베이스에서는 테이블 간의 관계를 외래키(foreign key) 등으로 구현하여 사용한다. |

이 핵심 구성 요소를 활용하여 데이터의 독립성(independency)과 무결성(integrity)과 같은 데이터를 안전하게 관리하기 위해 필요한 개념들을 정의하게 된다.

## 관계형 데이터베이스와 SQL

### 관계형 데이터베이스란?

관계형 데이터베이스는 앞에서 살펴본 관계형 데이터 모델 개념을 바탕으로 데이터를 저장, 관리하는 데이터베이스를 의미한다. 데이터베이스를 관리하는 시스템을 DBMS라고 불렀다. 관계형 데이터베이스를 관리하는 시스템은 DBMS에 데이터 간의 관계를 강조하기 위한 'relational'을 앞에 붙여 RDBMS(Relational Database Management System), 즉 관계형 데이터베이스 관리 시스템이라고 부른다. RDBMS는 1980년 후반부터 지금까지 가장 많이 사용하는 데이터베이스이다.

### SQL이란?

SQL은 Structured Query Language의 약자로 RDBMS에서 데이터를 다루고 관리하는 데 사용하는 데이터베이스 질의 언어이다. 

예를 들어 어떤 사용자가 응용 프로그램에 SQL을 사용하여 '우리 회사 각 부서별 사원이 몇 명 있는지 가르쳐 줘', '현재 접속한 사용자가 구매한 내역을 저장해 줘'와 같이 데이터 관련 내용을 데이터베이스에 물어보면 데이터베이스는 그 결과를 제공한다. 즉 우리는 SQL을 통해 데이터베이스에서 여러 데이터 관련 작업을 수행할 수 있다. SQL은 사용 목적에 따라서 다음과 같이 나뉜다.

| 종류                              | 설명                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| DQL(Data Query Language)          | RDBMS에 저장한 데이터를 원하는 방식으로 조회하는 명령어      |
| DML(Data Manipulation Language)   | RDBMS 내 테이블의 데이터를 저장, 수정, 삭제하는 명령어       |
| DDL(Data Definition Language)     | RDBMS 내 데이터 관리를 위해 테이블을 포함한 여러 객체를 생성, 수정, 삭제하는 명령어 |
| TCL(Transaction Control Language) | 트랜잭션 데이터의 영구 저장, 취소 등과 관련된 명령어         |
| DCL(Data Control Language)        | 데이터 사용 권한과 관련된 명령어                             |

# 관계형 DB와 오라클 DB

## 관계형 DB의 구성 요소

### 테이블

관계형 데이터베이스는 기본적으로 데이터를 2차원 표 형태로 저장하고 관리한다. 이 표 형태의 데이터 저장 공간을 테이블(table)이라고 한다. 테이블은 2차원 형태이므로 가로줄과 세로줄로 구성되는데요. 이때 가로줄을 행(row), 세로줄을 열(column)이라고 부른다.

**학생 정보 테이블**

| 학번     | 이름   | 생년월일 | 전화번호      | 집 주소   | 학년 | 학기 | 학과 코드 | 졸업 여부 | ...  |
| -------- | ------ | -------- | ------------- | --------- | ---- | ---- | --------- | --------- | ---- |
| 16031055 | 홍길동 | 971210   | 010-1111-1111 | 서울시... | 1    | 2    | COM       |           |      |
| 12071632 | 성춘향 | 940424   | 010-2222-2222 | 부산시... | 4    | 2    | BNS       | 졸업      |      |
|          |        |          | ...           |           |      |      |           |           |      |
| 15022655 | 박문수 | 960605   | 010-3333-3333 | 광주시... | 2    | 2    | MTH       |           |      |

#### 행

행은 저장하려는 하나의 개체를 구성하는 여러 값을 가로로 늘어뜨린 형태이다. 예를 들어 대학교에서 사용하는 학생 관리 프로그램에서 학생 데이터를 관리할 경우에 다음과 같이 학생을 구성하는 여러 값을 나열할 수 있다. 이때 테이블을 구성하는 하나의 행은 학번, 이름과 같은 여러 값으로 이루어진 학생 한 명의 데이터를 의미한다.

| 16031055 | 홍길동 | 971210 | 010-1111-1111 | 서울시... | 1    | 2    | COM  |
| -------- | ------ | ------ | ------------- | --------- | ---- | ---- | ---- |

#### 열

열을 저장하려는 데이터를 대표하는 이름과 공통 특성을 정의한다. 예를 들어 다음과 같이 각 학생의 데이터를 구성하는 학번과 이름, 그 외에 필요한 정보를 정의해 두면 각 학생의 학번, 이름, 학과 코드 등을 통일성 있게 저장할 수 있다. 그리고 열은 저장 정보의 종류(자료형)와 저장 가능한 값의 최대 길이 그리고 값의 중복을 허용하지 않는 등의 저장 조건과 범위를 지정할 수 있다.

| 학번     | 이름   | 학과 코드 |
| -------- | ------ | --------- |
| 16031055 | 홍길동 | COM       |
| 12071632 | 성춘향 | BNS       |
| ...      | ...    | ...       |
| 15022655 | 박문수 | MTH       |

#### 관계형 데이터베이스와 테이블

관계형 데이터베이스에서 관계란 행과 열의 특성에 맞추어 데이터를 저장한 테이블 하나하나를 의미한다. 여러 테이블의 구성과 관계를 잘 규정하고 관리하는 것이 관계형 데이터베이스에서 데이터를 관리하는 핵심이다.

**테이블, 행, 열**

> 정확히 말하면 테이블, 행, 열은 이후에 배울 관계형 데이터베이스의 SQL에서 사용한다. 관계형 데이터베이스에서 테이블은 관계(relation), 행은 튜플(tuple) 또는 레코드(record) 그리고 열은 속성을 의미하는 애트리뷰트(attribute) 또는 필드(field)라고 한다.

### 특별한 의미를 지닌 열, 키

어떤 문에 꼭 맞는 열쇠가 하나씩 있듯이 수많은 데이터를 구별할 수 있는 유일한 값이라는 뜻이다. 키는 하나의 테이블을 구성하는 여러 열 중에서 특별한 의미를 지닌 하나 또는 여러 열의 조합을 의미한다.

종류별로 데이터를 구별하거나 테이블 간의 연관 관계를 표한할 때 키로 지정한 열을 사용한다. 키는 기본키(primary key), 후보키(candidate key), 외래키(foreign key), 복합키(composite key) 등으로 구분할 수 있다.

#### 기본키

기본키는 여러 키 중에서 가장 중요한 키로서 한 테이블 내에서 중복되지 않는 값만 가질 수 있는 키이다. 기본키의 속성을 정리하면 다음과 같다.

> 기본키의 속성
>
> 1. 테이블에 저장된 행을 식별할 수 있는 유일한 값이어야 한다.
> 2. 값의 중복이 없어야 한다.
> 3. NULL 값을 가질 수 없다.

기본키는 중복되지 않는 유일한 값이라는 특성을 가졌기 때문에 하나 또는 여러 열의 조합으로 만들 수 있다.

예를 들어 다음과 같이 학생을 관리하는 학생 정보 테이블이 있다고 가정한다. 학생별로 특정 서비스를 제공하려면 각 학생을 구별할 수 있는 데이터가 반드시 필요하다. 이 경우에 학번, 아이디, 주민등록번호가 각 학생을 구별할 수 있는 데이터가 될 수 있다. 이들 중 한 열을 기본키로 지정한다. 대부분의 경우에 개인 정보 노출이 가장 적은 데이터를 선정하기 때문에 여기에서는 학번을 기본키로 지정했다.

| 학       | 아이디  | 주민등록번호   | 이름   | ...  |
| -------- | ------- | -------------- | ------ | ---- |
| 16031055 | baby    | 971210-1XXXXXX | 홍길동 |      |
| 12071632 | onemore | 940424-2XXXXXX | 성춘향 |      |
|          |         | ...            |        |      |
| 15022655 | time    | 960605-1XXXXXX | 박문수 |      |

#### 보조키

보조키는 대체키(alternate key)라고도 부르며 후보키(candidate key)에 속해 있는 키이다. 그리고 후보키 중에서 기본키로 지정되지 않은 열이다.

| 학번     | 아이디  | 주민등록번호   | 이름   | ...  |
| -------- | ------- | -------------- | ------ | ---- |
| 16031055 | baby    | 971210-1XXXXXX | 홍길동 |      |
| 12071632 | onemore | 940424-2XXXXXX | 성춘향 |      |
|          |         | ...            |        |      |
| 15022655 | time    | 960605-1XXXXXX | 박문수 |      |

위의 테이블을 살펴보면 유일한(중복되지 않은) 데이터를 가지고 있고 빈 값(NULL)이 없는 열(학번, 아이디, 주민등록번호)은 기본키가 될 수 있는 후보키이다. 그리고 후보키 중에서 기본키로 선택한 학번을 제외한 아이디와 주민등록번호가 보조키가 된다.

#### 외래키

외래키(FK : Foreign Key)는 특정 테이블에 포함되어 있으면서 다른 테이블의 기본키로 지정된 키를 의미한다.

다음 테이블을 살펴보면 학과 정보 테이블은 학과 코드, 학과 이름, 개설 날짜, 대학 구분, 대표 전화번호 등의 열로 구성되어 있다. 그리고 각 학과를 구별할 수 있는 유일한 데이터인 학과 코드를 기본키로 지정했다.

학생 정보 테이블을 보면 열 중에 학과 정보 테이블의 기본키인 '학과 코드'가 있다. 이 학과 코드가 바로 학생 정보 테이블과 학과 정보 테이블을 이어 주는 '외래키' 역할을 한다. 즉 학생 정보 테이블은 학과 코드를 통해 학과 정보 테이블의 세부 정보를 찾아갈 수 있다. 이를 학생 정보 테이블이 학과 코드를 '참조'한다고 표현한다. 학생 정보 테이블에서 학과 코드를 참조하여 학과 정보를 얻어 낼 수 있다.

**학생 정보 테이블**

| 학번     | 이름   | ...  | 학과 코드 | 졸업 여부 | ...  |
| -------- | ------ | ---- | --------- | --------- | ---- |
| 16031055 | 홍길동 | ...  | COM       |           |      |
| 12071632 | 성춘향 | ...  | BNS       | 졸업      |      |
|          |        | ...  |           |           |      |
| 15022655 | 박문수 | ...  | MTH       |           |      |

**학과 정보 테이블**

| 학과 코드 | 학과 이름    | 개설 날짜 | 대학 구분 | 대표 전화번호 | ...  |
| --------- | ------------ | --------- | --------- | ------------- | ---- |
| COM       | 컴퓨터공학과 | 19861021  | 공과대학  | 070-0000-0000 |      |
| BNS       | 경영학과     | 19730201  | 경상대학  | 070-1111-1111 |      |
|           |              | ...       |           |               |      |
| MTH       | 수학과       | 19730201  | 과학대학  | 070-2222-2222 |      |

예를 들어 성춘향 학생이 학과 대표 전화번호를 알아내기 위해 학사 정보 프로그램에 접속한다고 가정한다. 학사 정보 프로그램은 입력된 학번(학생 정보 테이블의 기본키)을 통해 학생 정보 테이블에서 성춘향 학생을 찾아냅니다. 그리고 성춘향 학생 행에 저장된 학과 코드(학과 정보 테이블의 기본키, 학생 정보 테이블의 외래키)를 활용해서 '학과 정보 테이블'을 찾아간다. 그러면 성춘향 학생이 속해 있는 해당 학과의 '대표 전화번호' 정보에 접근할 수 있다.

언듯 보면 외래키는 테이블을 두개로 따로 나누어 데이터를 사용하므로 번거로워 보일 수 있다. 만약 학과 코드를 외래키로 쓰지 않고 모든 정보를 하나의 학생 정보 테이블(기본키는 학번)에 저장한다고 생각해 본다. 다음 그림을 보면 학생 정보 테이블 옆에 학과 정보 테이블을 붙여 버린 것 같은 느낌이 든다.

학생 정보 테이블에는 당연히 같은 학과 학생들이 존재하기 때문에 같은 학과의 데이터가 학생 정보 테이블에 저장되면 다음과 같은 형태를 가지게 될 것이다.

위의 테이블에서 확인할 수 있듯이 학생 한 명의 데이터에 학과 데이터(학과 이름, 개설 날짜, 대학 구분 등)를 저장하면 같은 학과 학생인 경우에 똑같은 내용의 학과 데이터가 저장되기 때문에 엄청난 양의 중복 데이터가 저장되는 현상이 벌어진다.

데이터 중복을 왜 주의해야 하는가? 만약 학과 데이터 종류가 100개 정도 있고 학교에 학생은 매년 몇 천 명씩 입학한다고 가정할 때, 졸업생 데이터까지 고려한다면 해마다 중복 데이터가 빠른 속도로 늘어날 것이다.

또한 학과 정보를 변경해야 한다면 해당 학과에 소속된 학생 데이터 수만큼 데이터를 바꿔야 하므로 시간이 지날수록 데이터 중복에 따른 처리 비용이 증가하게 된다. 저장 공간 크기와 관리는 비용과 밀접한 관련이 있기 때문에 데이터 중복은 어쩔 수 없는 상황이 아닌 이상 반드시 피해야 한다.

관계형 데이터베이스에서는 엑셀처럼 여러 행에 걸쳐 특정 열을 병합하는 것이 기본적으로 불가능하다. 하지만 외래키를 사용하면 이러한 병합과 유사한 효과를 얻을 수 있어 데이터 중복을 최소화할 수 있다.

**응용 프로그램 개발과 외래키**

> 외래키는 데이터의 중복을 피하기 위해 테이블 사이의 관계를 규명하기 위한 필수 요소이다. 하지만 실무에서 데이터베이스를 활용하여 응용 프로그램을 만들 때 데이터의 구조 및 설계가 외래키를 사용해 너무 엄격하게 정의하면 응용 프로그램의 제작과 테스트 진행에 걸림돌이 된다. 
>
> 따라서 테이블 사이의 관계에서 개념적으로 외래키가 필수인 상황일지라도 응용 프로그램 제작의 효율 및 편의를 위해 외래키를 따로 정의하지 않고, 테이블 사이의 관계를 '느슨하게' 설계하여 이를 응용 프로그램 영역에서 처리하는 경우도 종종 발생한다. 

**복합키**

여러 열을 조합하여 기본키 역할을 할 수 있게 만든 키이다.

## 오라클 DB

### 오라클 데이터베이스와 버전

대부분의 기업에서 11g 버전을 사용하고 있다. 일반적으로 현업에서 DB를 한번 구축하면 버전 업그레이드가 쉽지 않기 때문이다.

### 자료형

| 자료형                                  | 설명                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| VARCHAR2(길이)                          | 4000byte만큼의 가변 길이 문자열 데이터를 저장할 수 있다(최소 크기는 1byte). |
| NUMBER(전체 자릿수, 소수점 이하 자릿수) | +-38자릿수의 숫자를 저장할 수 있다.<br />NUMBER(p, s)와 같이 표기할 경우 s자리만큼 소수점 이하 자릿수를 표현하고, 이 소수점 자리를 포함한 전체 p자리만큼 숫자 데이터를 저장한다. |
| DATE                                    | 날짜 형식을 저장하기 위해 사용하는 자료형으로 세기, 연, 월, 일, 시, 분, 초 저장이 가능하다. |
| CHAR(길이)                              | 4000byte만큼의 고정 길이 문자열 데이터를 저장할 수 있다(최소 크기는 1byte). |
| NVARCHAR2(길이)                         | 4000byte만큼의 가변 길이 국가별 문자 세트 데이터를 저장할 수 있다(최소 크기는 1byte). |
| BLOB                                    | 최대 크기 4GB의 대용량 이진 데이터를 저장할 수 있다.         |
| CLOB                                    | 최대 크기 4GB의 대용량 텍스트 데이터를 저장할 수 있다.       |
| BFILE                                   | 최대 크기 4GB의 대용량 이진 데이터 파일을 저장할 수 있다.    |

자료형은 테이블을 구성하는 열에 지정한다. 예를 들어 NUMBER(4)로 지정한 열이 있다면 네 자리 숫자만 저장할 수 있다. 이 열에는 문자열을 저장할 수 없고 다섯 자리 숫자를 저장할 수도 없다. 이렇게 하나의 자료형에 맞춰 한 종류의 데이터를 저장할 수 있는 자료형을 스칼라(scalar)형이라고 한다.

자료형은 여러 종류가 있으며 한 번에 여러 데이터를 저장할 수 있는 VARRAY, NESTED TABLE 같은 컬렉션(collection)형도 있다.

### 객체

| 객체                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| 테이블(table)       | 데이터를 저장하는 장소                                       |
| 인덱스(index)       | 테이블의 검색 효율을 높이기 위해 사용함                      |
| 뷰(view)            | 하나 또는 여러 개의 선별된 데이터를 논리적으로 연결하여 하나의 테이블처럼 사용하게 해 줌 |
| 시퀀스(sequence)    | 일련 번호를 생성해 줌                                        |
| 시노님(synonym)     | 오라클 객체의 별칭(다른 이름)을 지정함                       |
| 프로시저(procedure) | 프로그래밍 연산 및 기능 수행이 가능함(반환 값 없음)          |
| 함수(function)      | 프로그래밍 연산 및 기능 수행이 가능함(반환 값 있음)          |
| 패키지(package)     | 관련 있는 프로시저와 함수를 보관함                           |
| 트리거(trigger)     | 데이터 관련 작업의 연결 및 방지 관련 기능을 제공함           |

### PL/SQL

오라클 DB를 포함한 여러 관계형 DB에서 데이터를 관리하기 위해 복잡한 기능이 필요할 때 기존 SQL만으로 이를 구현하는 것은 다소 한계가 있다. 그 이유는 PL/SQL에서 제공하는 다양한 프로그래밍 요소를 사용할 줄 알아야 하고 구현하려는 프로그램이 다루는 데이터의 관계도 이해해야 하기 때문이다.

**변수, 조건문, 반복문이란?**

> * 변수 : 변수는 특정 값을 저장하는 메모리 공간이다. 예를 들어 로그인을 위해 사용자가 아이디와 비밀번호를 입력하면 입력된 값이 정확한지 확인하기 전까지 일시적으로 저장하는 공간이 있는데 이것이 변수이다.
> * 조건문 : 특정 조건에 따라 다른 기능을 수행하는 코드를 작성할 때 사용한다. 
> * 반복문 : 특정 기능을 반복하여 수행할 때 사용한다.

# 오라클 DB와 도구 프로그램

## JAVA JDK 설치

다운로드 버전 : Java 17 LTS

Java 17 LTS 버전을 다운받은 후 환경변수 설정

이후,

```cmd
java -version
```

명령어를 통해 설치가 되었는지 확인

## 오라클 DB 설치 및 접속

다운로드 버전 : Oracle Database 21c

설치를 하면 시스템 계정의 패스워드 설정을 하게된다. 설정을 마친 후 다음 명령어로 시스템 계정에 접속해본다.

````sql
sqlplus system/0000
````

sqlplus는 오라클 데이터베이스 접속용 프로그램으로 오라클 데이터베이스를 설치할 때 함께 설치된다. system은 앞에서 설치한 오라클 데이터베이스에 접속하는 시스템 계정이며, 0000은 오라클 데이터베이스를 설치하면서 설정한 패스워드이다. system 계정은 오라클 데이터베이스에서 최고 권한을 가진 SYS 계정의 데이터베이스 관리 권한을 위임받은 강력한 관리용 계정이다. 다음은 system 계정을 통해 확인할 수 있는 주요 항목들이다.

1. 사용자 및 역할

   * 사용자 목록 조회

     데이터베이스에 등록된 모든 사용자 계정을 확인하려면 DBA_USERS 뷰를 사용한다.

     ```sql
     SELECT username FROM dba_users;
     ```

     * USERNAME은 데이터베이스 사용자 계정을 나타낸다.

     * 예를 들어, 계정 상태(열 ACCOUNT_STATUS)나 계정 생성 날짜(CREATED) 등을 추가로 조회할 수도 있다.

       * ACCOUNT_STATUS의 값으로 다양한 상태를 확인할 수 있다. 주요 출력 결과와 그 의미는 다음과 같다.

         | ACCOUNT_STATUS   | 설명                                                         |
         | ---------------- | ------------------------------------------------------------ |
         | OPEN             | 계정이 활성 상태이며, 정상적으로 로그인 가능                 |
         | LOCKED           | 계정이 잠겨 있어 사용자가 로그인할 수 없다. 주로 보안 상의 이유로 잠금 설정된다. |
         | EXPIRED          | 계정의 비밀번호가 만료된 상태이다. 사용자가 새로운 비밀번호를 설정해야 로그인이 가능하다. |
         | LOCKED(TIMED)    | 계정이 잠시 동안 잠금 상태로 유지된다. 이는 잘못된 로그인 시도가 일정 횟수를 초과했을 때 발생한다. |
         | EXPIRED $ LOCKED | 계정이 비밀번호 만료와 함께 잠겨 있는 상태이다.              |
         | EXPIRED (GRACE)  | 비밀번호가 만료되었지만 관리자가 설정한 유예 기간 동안 로그인 가능하며 새 비밀번호를 설정해야 한다. |

     * 추가 쿼리 :

       ```SQL
       SELECT username, account_status, created FROM dba_users;
       ```

       결과 : 

       ```
       USERNAME
       ------------------------------------------------------------
       ACCOUNT_STATUS                                                   CREATED
       ---------------------------------------------------------------- --------
       SYS
       OPEN                                                             14/05/29
       
       SYSTEM
       OPEN                                                             14/05/29
       
       ANONYMOUS
       OPEN                                                             14/05/29
       
       USERNAME
       ------------------------------------------------------------
       ACCOUNT_STATUS                                                   CREATED
       ---------------------------------------------------------------- --------
       APEX_PUBLIC_USER
       LOCKED                                                           14/05/29
       
       FLOWS_FILES
       LOCKED                                                           14/05/29
       
       APEX_040000
       LOCKED                                                           14/05/29
       
       
       USERNAME
       ------------------------------------------------------------
       ACCOUNT_STATUS                                                   CREATED
       ---------------------------------------------------------------- --------
       OUTLN
       EXPIRED & LOCKED                                                 14/05/29
       
       DIP
       EXPIRED & LOCKED                                                 14/05/29
       
       ORACLE_OCM
       EXPIRED & LOCKED                                                 14/05/29
       
       
       USERNAME
       ------------------------------------------------------------
       ACCOUNT_STATUS                                                   CREATED
       ---------------------------------------------------------------- --------
       XS$NULL
       EXPIRED & LOCKED                                                 14/05/29
       
       MDSYS
       EXPIRED & LOCKED                                                 14/05/29
       
       CTXSYS
       EXPIRED & LOCKED                                                 14/05/29
       
       
       USERNAME
       ------------------------------------------------------------
       ACCOUNT_STATUS                                                   CREATED
       ---------------------------------------------------------------- --------
       DBSNMP
       EXPIRED & LOCKED                                                 14/05/29
       
       XDB
       EXPIRED & LOCKED                                                 14/05/29
       
       APPQOSSYS
       EXPIRED & LOCKED                                                 14/05/29
       
       
       USERNAME
       ------------------------------------------------------------
       ACCOUNT_STATUS                                                   CREATED
       ---------------------------------------------------------------- --------
       HR
       EXPIRED & LOCKED                                                 14/05/29
       ```

   * 특정 사용자의 역할 확인

     사용자가 부여받은 역할을 조회할 수 있다.

     ```sql
     SELECT granted_role FROM dba_role_privs WHERE grantee = '사용자명';
     ```

     * 이 명령은 특정 사용자(grantee)에게 할당된 모든 역할 목록을 보여줍니다.

2. 스키마와 테이블

   * 스키마의 테이블 확인

     특정 스키마에 속한 테이블의 목록 확인

     ```sql
     SELECT table_name FROM all_tables WHERE owner = '스키마명';
     ```

     * ALL_TABLES 뷰는 현재 로그인된 사용자가 접근 가능한 테이블 목록을 제공한다.

   * 테이블 구조 확인

     특정 테이블의 상세 정보 확인

     ```SQL
     DESC 스키마명.테이블명;
     ```

     * 이 명령은 테이블에 포함된 컬럼 이름, 데이터 타입, 제약 조건 등을 보여준다.

3. 세션 관리

   * 현재 활성 세션 조회

     데이터베이스에 연결된 세션 정보를 확인한다.

     ```SQL
     SELECT sid, serial#, username, status FROM v$session;
     ```

     * SID 및 SERIAL# 값은 세션의 고유 식별자이며, 이를 사용해 특정 세션을 종료할 수 있다.

   * 특정 세션 종료

     비정상적으로 동작하는 세션을 종료하려면

     ```SQL
     ALTER SYSTEM KILL SESSION 'SID,SERIAL#';
     ```

     * 이 명령은 시스템 자원을 효율적으로 관리하는 데 유용하다.

4. 성능 모니터링

   * 성능 통계 확인

     데이터베이스의 현재 상태를 나타내는 주요 통계를 확인

     ```SQL
     SELECT name, value FROM v$sysstat WHERE rownum <= 10;
     ```

     * 예를 들어, 데이터베이스의 물리적I/O나 캐시 효율성 정보를 조회할 수 있다.

   * 쿼리 실행 계획 확인

     쿼리 튜닝을 위한 실행 계획 확인 :

     ```sql
     EXPLAIN PLAN FOR SELECT * FROM 테이블명;
     SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
     ```

     * 첫 번째 명령은 쿼리의 실행 계획을 저장하며, 두 번째 명령은 저장된 실행 계획을 출력한다.

5. 데이터베이스 구성 정보

   * 초기화 파라미터 확인

     데이터베이스의 설정 값을 확인하려면 : 

     ```SQL
     SELECT name, value FROM v$parameter;
     ```

     * 여기에는 메모리 설정, 로그 파일 경로 등의 정보를 포함

   * 테이블스페이스 정보 조회

     테이블스페이스의 상태를 확인하려면 : 

     ```sql
     SELECT tablespace_name, status FROM dba_tablespaces;
     ```

     * 결과에는 테이블 스페이스의 이름과 현재 상태(ONLINE, OFFLINE 등)가 포함된다.

6. 백업 및 복구 관련 로그

   * 백업 상태 확인

     백업 진행 상황을 확인하려면 : 

     ```SQL
     SELECT * FROM v$backup;
     ```

     * 이 뷰는 데이터파일별 백업 상태를 보여준다.

   * 아카이브 로그 확인

     복구 시 필요한 로그 파일을 확인하려면 : 

     ```sql
     SELECT sequence#, first_time, next_time FROM v$archived_log;
     ```

     * SEQUENCE#는 로그 고유 ID를 나타내며, FIRST_TIME과 NEXT_TIME은 로그가 생성된 시간을 나타낸다.

### 오라클 데이터베이스 접속 및 SCOTT 계정 설정

1. 접속하기

   ```SQL
   sqlplus system/0000
   ```

   접속 계정 확인

   ```
   SELECT USER FROM dual;
   ```

2. SCOTT 계정이 존재하는지 확인

   * 존재하지 않는 경우 - SCOTT 계정 생성 및 활성화

     SYSTEM 계정으로 접속한 뒤, 다음 명령어를 실행하여 SCOTT 계정을 생성하고 활성화할 수 있다.

     1. 계정 생성(루트 컨테이너에서 작업 및 특정 PDB에서 작업)

        ```SQL
        ALTER SESSION SET CONTAINER = CDB$ROOT;
        CREATE USER C##SCOTT IDENTIFIED BY 0000 CONTAINER=ALL;
        GRANT CONNECT, RESOURCE TO C##SCOTT CONTAINER=ALL;
        ```

        ```SQL
        ALTER SESSION SET CONTAINER = <PDB_NAME>;
        GRANT UNLIMITED TABLESPACE TO C##SCOTT;
        ```

        ```SQL
        CREATE USER C##SCOTT IDENTIFIED BY tiger;
        ```

        cf) : C##은 Oracle 12c 및 이후 버전에서 발생하며, 이는 사용자 이름이 컨테이너 데이터베이스(CDB) 환경에서 일반 사용자(Common User) 명명 규칙을 따르지 않기 때문이다. 이 버전에서는 기본적으로 사용자 이름이 C##로 시작하는 공통 사용자만 허용된다. 해당 사용자로 접속할 시에도 C## 명명규칙을 따라야 한다. DBeaver나 SQL Developer에서도 C## 네이밍 규칙을 적용해야 한다.

     2. 필요한 권한 부여

        ```SQL
        GRANT CONNECT, RESOURCE TO C##SCOTT;
        ```

        * CONNECT 권한 : 데이터베이스 접속 권한을 부여한다.
        * RESOURCE 권한 : 테이블 등 객체를 생성할 수 있는 권한을 부여한다.

     3. 예제 스키마 데이터 추가하기

        SCOTT 계정에는 일반적으로 EMP와 DEPT 같은 예제 테이블이 포함되어 있다. 이를 추가하려면 utlsampl.sql 스크립트를 실행해야 한다.

        1. 샘플 스키마 스크립트 위치 확인

           * Linux/Unix : $ORACLE_HOME/rdbms/admin/utlsampl.sql
           * Windows : %ORACLE_HOME%\rdbms\admin\utlsampl.sql

        2. 스크립트 실행

           Oracle SQL*Plus에서 다음 명령어를 실행하여 스크립트를 로드한다.

           아래의 `@?`는 스크립트 실행 명령어이다.

           * @ : SQL 스크립트를 실행하라는 명령
           * ? : Oracle의 설치 디렉토리 경로를 나타낸다. 이는 환경 변수 `ORACLE_HOME`에 설정된 값과 동일하다.

           ```sql
           @?/rdbms/admin/scott.sql
           ```

           여기서 utlsampl.sql의 scott 패스워드가 tiger로 되어있으므로 이를 0000으로 변경해준다.

           ※ cf) : scott.sql 스크립트 실행 시 컨테이너 참조 범위 확인

           ```SQL
           ALTER SESSION SET CONTAINER = CDB$ROOT;
           GRANT CONNECT,RESOURCE,UNLIMITED TABLESPACE TO C##SCOTT IDENTIFIED BY 0000 CONTAINER = ALL;
           ALTER USER C##SCOTT DEFAULT TABLESPACE USERS;
           ALTER USER C##SCOTT TEMPORARY TABLESPACE TEMP;
           CONNECT C##SCOTT/0000
           ...
           ```

           * 데이터베이스 컨테이너

             Oracle Database의 멀티테넌트 아키텍처에서 도입된 개념으로, 여러 데이터베이스를 효율적으로 관리하고 통합하기 위한 프레임워크. 쉽게 말하면, 컨테이너는 데이터를 담는 "큰 그릇"처럼 작동하며, 그 안에 여러 데이터베이스(PDB)를 개별적으로 담을 수 있다.

             * 데이터베이스 컨테이너의 주요 특징

               1. 루트 컨테이너(CDB$ROOT)(CDB : Container Database)

                  * 모든 PDB가 공유하는 공통 구성 요소(예 : 데이터 딕셔너리, 시스템 데이터)와 인프라를 포함

                    > cf) : 데이터 딕셔너리란?
                    >
                    > * 정의
                    >
                    >   데이터베이스의 모든 구조와 객체에 대한 정보를 저장하는 시스템 데이터베이스이다.
                    >
                    > * 목적
                    >
                    >   DBMS가 데이터베이스를 관리하고 운영하기 위해 필요한 메타데이터(데이터에 대한 데이터)를 저장한다.
                    >
                    > * 구성 요소
                    >
                    >   * 테이블, 뷰, 인덱스, 사용자, 권한 등 데이터베이스 구조와 관련된 정보를 포함한다.
                    >
                    >     ex) 테이블의 이름과 컬럼, 데이터 타입, 키 제약 조건, 데이터 크기 등.
                    >
                    > * 주요 특징
                    >
                    >   1. 자동 생성 및 유지
                    >      * 데이터베이스를 생성하거나 변경할 때 데이터 딕셔너리도 자동으로 업데이트된다.
                    >   2. 시스템 관리용
                    >      * DBA(Database Administrator)나 시스템 데이터베이스를 관리하는 데 활용한다.
                    >   3. 읽기 전용
                    >      * 일반 사용자에게는 읽기 전용이며, 직접 수정할 수 없다.
                    >   4. 뷰 제공
                    >      * 사용자는 `USAR_`, `ALL_`, `DBA_`로 시작하는 뷰를 통해 데이터 딕셔너리 정보를 확인할 수 있다.
                    >
                    > * 예시
                    >
                    >   1. USER_TABLES
                    >
                    >      * 사용자가 소유한 테이블 목록을 제공한다.
                    >
                    >        ```SQL
                    >        SELECT * FROM USER_TABLES;
                    >        ```
                    >
                    >   2. ALL_OBJECTS
                    >
                    >      * 사용자가 접근할 수 있는 데이터베이스 객체(테이블, 뷰, 인덱스 등) 목록을 제공한다.
                    >
                    >   3. DBA_USERS
                    >
                    >      * 모든 데이터베이스 사용자 계정 정보를 보여준다(관리자만 접근 가능).

                  * 데이터베이스 관리자가 주요 설정과 작업(예 : 패치 적용, 업그레이드)을 수행하는 공간

               2. 플러그형 데이터베이스(PDB : Pluggable Database)

                  * 컨테이너 안에 있는 개별 데이터베이스로, 각 PDB는 독립적으로 운영될 수 있다.
                  * 서로 분리되어 있어, 하나의 PDB가 문제가 생겨도 다른 PDB에 영향을 주지 않는다.

               3. 컨테이너 관리의 장점

                  * 데이터베이스 통합

                    여러 PDB를 하나의 컨테이너로 관리하여 리소스를 효율적으로 사용한다.

                  * 유연성

                    PDB를 쉽게 플러그(삽입)하거나 언플러그(제거)할 수 있어, 다른 환경으로 이동이 가능하다.

                  * 중앙화된 관리

                    CDB 수준에서 보안 정책, 업데이트, 백업 등을 통합 관리한다.

                  * 공유와 독립성

                    CDB는 여러 PDB가 공유하는 시스템 인프라를 제공하지만, 각 PDB는 독립적으로 관리된다. 예를 들어, 특정 PDB를 업그레이드하거나 이전하더라도 다른 PDB에 영향을 주지 않는다.

                  * 보안 및 권한 관리

                    * CDB 수준에서는 DBA가 전체 데이터베이스의 보안 정책과 권한을 설정한다.
                    * PDB 내부에서는 각 PDB 관리자(Local DBA)가 사용자와 데이터를 독립적으로 관리한다.

             * CDB 아키텍처의 작동 흐름

               1. 클라이언트 요청이 들어오면 CDB는 요청을 처리할 올바른 PDB로 라우팅한다.
               2. PDB는 요청에 따라 개별 데이터를 처리하고 결과를 반환한다.
               3. 모든 시스템 수준 관리 작업(예 : 백업, 패치)은 CDB 루트에서 실행되며, 필요한 경우 각 PDB에 적용된다.

             * CDB 아키텍처의 시각적 예시

               ```
               CDB (컨테이너 데이터베이스)
               ├── CDB$ROOT (루트 컨테이너)
               │    ├── 시스템 데이터
               │    ├── 공통 데이터 딕셔너리
               │    ├── 공통 사용자 계정
               │
               ├── PDB1 (플러그형 데이터베이스 1)
               │    ├── 사용자 데이터
               │    ├── 고유 스키마
               │
               ├── PDB2 (플러그형 데이터베이스 2)
               │    ├── 사용자 데이터
               │    ├── 고유 스키마
               │
               └── PDBn (플러그형 데이터베이스 n)
                    ├── 사용자 데이터
                    ├── 고유 스키마
               ```

        3. 이 스크립트는 SCOTT 계정에 예제 테이블 데이터를 삽입한다.

   * 존재할 경우 - SCOTT 계정을 사용할 수 있도록 설정하기

     오라클 DB에서는 기본 학습을 위한 테이블과 데이터가 미리 구현되어 있는 SCOTT 계정을 제공한다. 이 계정은 오라클 DB 설치 직후에는 잠겨 있는 상태이므로 사용 가능 상태로 전환해 주어야 한다.

     ```sql
     ALTER USER SCOTT -- SCOTT 계정을 변경하겠다는 의미
     IDENTIFIED BY tiger -- 접속 비밀번호를 tiger로 지정한다는 의미
     ACCOUNT UNLOCK; -- 계정을 사용 가능 상태(잠기지 않은 상태로) 전환한다는 의미
     ```

3. SCOTT 계정에 접속 후 간단한 명령어 실행해 보기

   SCOTT 계정에 접속하기 위해 다음 명령어를 실행한다. SQL*PLUS에 정상 접속해 있는 상태에서 CONN 명령어를 사용하여 다른 계정으로 재접속할 수 있다.

   ```SQL
   CONN C##SCOTT/tiger;
   ```

   이후 desc 명령어를 실행하여 EMP 테이블 구성을 확인한다.

   ```sql
   DESC EMP;
   ```

4. 데이터베이스 연결 종료하기

   명령 프롬프트를 종료하거나 exit 명령어를 사용하면 오라클 DB 연결이 종료된다.

   ```sql
   EXIT
   ```

5. SCOTT 계정으로 연결하기

   ```sql
   SQLPLUS c##scott/tiger
   ```

## 데이터베이스 관리 도구

* 데이터베이스를 전반적으로 관리하기 위한 도구이다.
* 기능에는 사용자 및 권한 관리, 데이터베이스 백업 및 복구, 성능 모니터링, 테이블스페이스 관리 등이 포함된다.
* 자주 쓰이는 도구로는 Toad for Oracle, SQL Developer, DBeaver가 있다.
* 주로 데이터베이스 관리자(DBA)와 개발자가 데이터베이스 설정 및 유지보수를 위해 사용한다.

### 대표적인 데이터베이스 관리 도구

1. Toad for Oracle

   * 장점

     * Oracle 데이터베이스 관리에 특화되어 있어 고급 기능 지원
     * SQL 튜닝, 쿼리 최적화, 데이터 분석 기능이 강력함
     * GUI 인터페이스가 직관적이며, 스크립트 실행 및 결과 관리가 용이함
     * 대규모 데이터베이스 작업에서 효율적이고 안정적인 성능을 제공
     * 많은 기업에서 이미 사용되고 있어 지원 커뮤니티와 자료가 풍부

   * 단점

     * 상용 소프트웨어로, 무료로 사용할 수 없으며 라이선스 비용이 존재
     * 초보자에게는 기능이 다소 복잡하고 방대하다.

   * 추천 대상

     대규모 Oracle 데이터베이스를 관리하고, 고급 SQL 튜닝 및 디버깅 기능이 필요한 전문 DBA나 개발자

2. DBeaver

   * 장점

     * 다중 데이터베이스 지원(MySQL, PostgreSQL, Oracle 등 다수의 DBMS에 연결 가능)
     * 오픈 소스 버전 제공(무료) 및 유료 버전(엔터프라이즈)으로 확장 가능
     * 범용성 및 사용 편의성이 뛰어나며, 다양한 데이터베이스 간 작업을 통합적으로 처리 가능
     * 사용자 정의가 가능하며, 플러그인 및 확장 기능 제공

   * 단점

     * Oracle 전용 기능은 제한적일 수 있음(특화된 Oracle 기능은 Toad나 SQL Developer가 더 적합)
     * 대규모 데이터베이스 작업이나 고급 쿼리 튜닝에서 제한될 수 있다.

   * 추천 대상

     여러 데이터베이스를 동시에 사용하거나, 무료로 강력한 도구를 필요로 하는 사용자 및 초보 개발자

3. SQL Developer

   * 장점

     * Oracle에서 무료로 제공하는 공식 도구
     * Oracle 데이터베이스와의 호환성이 뛰어나며, 기본적인 작업에서 안정적인 성능을 제공
     * PL/SQL 디버깅 및 SQL 튜닝 어드바이저 등 Oracle-specific 기능을 포함
     * 가벼운 실행 환경과 쉬운 설치

   * 단점

     * 인터페이스가 다소 직관적이지 않을 수 있음(특히 처음 사용하는 경우)
     * 대규모 데이터베이스 작업에서는 속도가 느리게 느껴질 수도 있음

   * 추천 대상

     Oracle 데이터베이스와 작업하는 초보자나, 비용 문제 없이 Oracle 공식 도구를 선호하는 사용자

현재 학습하는 주제는 Oracle DB이고 다른 DB 역시 학습할 것이기에 DBeaver를 설치한다.

## 오라클 삭제하는 방법

### 삭제 전 유의점

오라클 데이터베이스의 삭제는 다른 윈도우 응용 프로그램의 삭제보다 진행이 까다롭다. 특히 레지스트리를 직접 삭제하는 부분은 어렵기도 하지만 상당히 위험한 작업이다. 자칫 상관없는 레지스트리를 잘못 건드리면 다른 프로그램이나 윈도우가 잘 동작하지 않을 수도 있기 때문에 꼼꼼히 살피고 삭제를 진행해야 한다. 

만약 이런 부분이 너무 어렵다면 오라클 데이터베이스의 사용을 중지시키고 deinstall.bat를 사용하여 오라클 데이터베이스를 삭제한 후 오라클 데이터베이스 관련 폴더만 삭제하고 레지스트리 부분은 시중에 나와 있는 레지스트리 청소 프로그램을 사용하는 것도 하나의 방법이다.

### 삭제하는 방법

일반적인 삭제 순서는 다음과 같다.

1. 오라클 데이터베이스 서비스 중지
2. 전용 삭제 프로그램을 사용하여 삭제
3. 하드디스크에서 오라클 데이터베이스 폴더 삭제
4. 레지스트리 영역 삭제
5. 시작 메뉴를 비롯한 기타 파일 삭제

# SELECT문의 기본 형식

## 실습용 테이블 살펴보기

DESC 명령어를 사용하여 SCOTT 계정의 테이블의 구성을 살펴본다.

```sql
DESC EMP;
DESC DEPT;
DESC SALGRADE;
```

## 데이터 조회 방법-셀렉션, 프로젝션, 조인

### 행 단위로 조회하는 셀렉션

SELECTION은 행 단위로 원하는 데이터를 조회하는 방식이다. 테이블 전체 데이터 중 몇몇 가로줄의 데이터만 선택할 때 사용한다.

### 열 단위로 조회하는 프로젝션

PROJECTION은 열 단위로 원하는 데이터를 조회하는 방식이다.

### 셀렉션과 프로젝션 함께 사용하기

특정 테이블에서 조회하려는 행과 열을 모두 션별할 때 셀렉션과 프로젝션을 함께 사용할 수 있다.

예를 들어 전체 학생 중 졸업생만을 조회하되 학번, 이름, 학과 코드 항목만 출력되도록 선택하는 것이다.

| 학번         | 이름       | ...  | 학과 코드 | 졸업 여부 | ...  |
| ------------ | ---------- | ---- | --------- | --------- | ---- |
| 16031055     | 홍길동     |      | COM       |           |      |
| **12071632** | **성춘향** |      | **BN5**   | **졸업**  |      |
| ...          |            | ...  |           |           |      |
| 15022655     | 박문수     |      | MTH       |           |      |

### 두 개 이상의 테이블을 사용하여 조회하는 조인

JOIN은 두 개 이상의 테이블을 양옆에 연결하여 마치 하나의 테이블인 것처럼 데이터를 조회하는 방식이다. 이전에 외래키를 알아보며 학생 정보와 학과 정보를 하나의 테이블처럼 연결하여 사용하는 예를 살펴보았다. 그 예와 같이 조인은 관계형 데이터베이스에서 흔히 사용하는 방식으로 여러 테이블의 데이터를 하나의 테이블처럼 조회할 수 있다.

## SELECT FROM 절

SELECT문은 데이터베이스에 보관되어 있는 데이터를 조회하는 데 사용한다. SELECT절과 FROM절을 기본 구성으로 SELECT문을 작성하는데, FROM절은 조회할 데이터가 저장된 테이블 이름을 명시한다. 그리고 SELECT절은 FROM절에 명시한 테이블에서 조회할 열이나 여러 열에 저장된 데이터의 조합 또는 연산식을 지정할 수 있다.

```SQL
SELECT [조회할 열1 이름],[열2 이름], ... ,[열N이름]
FROM [조회할 테이블 이름];
```

### *로 테이블 전체 '열' 출력하기

```SQL
SELECT * FROM EMP;
```

### 테이블 부분 열 출력하기

```SQL
SELECT EMPNO, ENAME, DEPTNO
FROM EMP;
```

## DISTINCT

SELECT문으로 데이터를 조회한 후 DISTINCT를 사용하여 중복을 제거한다. DISTINCT는 SELECT절에 열 이름을 명시하기 전에 선택적으로 사용할 수 있다.

```SQL
SELECT DISTINCT DEPTNO FROM EMP;
```

### DISTINCT로 열 중복 제거하기(열이 여러 개인 경우)

```SQL
SELECT DISTINCT JOB, DEPTNO
FROM EMP;
```

### ALL로 중복되는 열 제거 없이 그대로 출력하기

```SQL
SELECT ALL JOB, DEPTNO
FROM EMP;
```

## 별칭 설정

SQL문에서는 최종 출력되는 열 이름을 임의로 지정할 수도 있다. 이렇게 본래 열 이름 대신 붙이는 이름을 별칭(alias)이라고 한다.

### 열과 연산식

```sql
SELECT ENAME, SAL, SAL*12+COMM, COMM
FROM EMP;
```

### 별칭을 지정하는 방식

| 사용방법                | 설명                                                         |
| ----------------------- | ------------------------------------------------------------ |
| SAL*12+COMM ANNSAL      | 연산 및 가공된 문장 이후 한 칸 띄우고 별칭 지정              |
| SAL*12+COMM "ANNSAL"    | 연산 및 가공된 문장 이후 한 칸 띄우고 별칭을 큰따옴표로 묶어 지정 |
| SAL*12+COMM AS ANNSAL   | 연산 및 가공된 문장 이후 한 칸 띄운 후 'AS', 한 칸 뒤에 별칭 지정 |
| SAL*12+COMM AS "ANNSAL" | 연산 및 가공된 문장 이후 한 칸 띄운 후 'AS', 한 칸 뒤에 별칭을 큰따옴표로 묶어 지정 |

```SQL
SELECT ENAME, SAL, SAL*12+COMM AS ANNSAL, COMM
FROM EMP;
```

### 실무에서의 별칭 지정

```SQL
String sql = "SELECT ENAME, SAL, SAL*12+COMM AS ANNSAL, COMM FROM EMP";
```

```SQL
String sql = "SELECT ENAME, SAL, SAL*12+COMM AS "ANNSAL", COMM FROM EMP";
```

## ORDER BY

```
SELECT [조회할 열1 이름], [열2 이름], ... , [열N 이름]
FROM [조회할 테이블 이름]
.
.
.
ORDER BY [정렬하려는 열 이름(여러 열 지정 가능)] [정렬 옵션];
```

cf) : 정렬 옵션

* 오름차순 : ASC(defalt)
* 내림차순 : DESC

### 오름차순 사용하기

```SQL
SELECT *
FROM EMP
ORDER BY SAL;
```

### 내림차순 사용하기

```SQL
SELECT *
FROM EMP
ORDER BY SAL DESC;
```

### 각각의 열에 내림차순과 올림차순 동시에 사용하기

ORDER BY절에는 우선순위를 고려하여 여러 개의 정렬 기준을 지정할 수 있다. 예를 들어 부서 번호(DEPTNO)를 오름차순으로 정렬하고, 부서 번호가 같은 사원일 경우 급여(SAL)를 기준으로 내림차순으로 정렬할 수도 있다. 

```SQL
SELECT *
FROM EMP
ORDER BY DEPTNO ASC, SAL DESC;
```

# WHERE절과 연산자

## WHERE절

WHERE절은 SELECT문으로 데이터를 조회할 때 특정 조건을 기준으로 원하는 행을 출력하는 데 사용한다. 그리고 여러 연산자를 함께 사용하면 더욱 세밀하게 데이터 검색을 할 수 있다.

```SQL
SELECT [조회할 열1 이름], ... , [열N이름]
FROM [조회할 테이블 이름]
WHERE [조회할 행을 선별하기 위한 조건식];
```

```SQL
SELECT *
FROM EMP
WHERE DEPTNO = 30;
```

## AND, OR 연산자

```SQL
SELECT *
FROM EMP
WHERE DEPTNO = 30
AND JOB = 'SALEMAN';
```

```SQL
SELECT *
FROM EMP
WHERE DEPTNO = 30
OR JOB = 'CLERK';
```

### WHERE절 조건식의 개수

```SQL
SELECT *
FROM EMP
WHERE [조건식1]
AND [조건식2]
OR [조건식3]
...
AND [조건식N]
```

## 연산자 종류와 활용법

### 산술 연산자

```SQL
SELECT *
FROM EMP
WHERE SAL * 12 = 36000;
```

### 비교 연산자

**대소 비교 연산자**

```SQL
SELECT *
FROM EMP
WHERE SAL >= 3000;
```

```SQL
SELECT *
FROM EMP
WHERE ENAME >= 'F'
```

```SQL
SELECT *
FROM EMP
WHERE ENAME <= 'FORZ';
```

**등가 비교 연산자**

| 연산자 | 사용법 | 의미                                               |
| ------ | ------ | -------------------------------------------------- |
| =      | A = B  | A 값이 B 값과 같을 경우 true, 다를 경우 false 반환 |
| !=     | A != B | A 값과 B 값이 다를 경우 true, 같을 경우 false 반환 |
| <>     | A <> B | ``                                                 |
| ^=     | A ^= B | ``                                                 |

만약 급여가 3000이 아닌 사원의 데이터를 조회할 때 다음과 같이 select문을 작성할 수 있다. '같지 않다'는 의미로 사용할 수 있는 세 가지 방식 모두 같은 결과 값을 출력한다.

```SQL
SELECT *
FROM EMP
WHERE SAL != 3000;
```

```sql
SELECT *
FROM EMP
WHERE SAL <> 3000;
```

```SQL
SELECT *
FROM EMP
WHERE SAL ^= 3000;
```

### 논리 부정 연산자

만약 A값이 TRUE일 경우 논리 부정 연산자의 결과 값은 FALSE가 된다. 반대로 A 값이 FALSE인 경우에 논리 부정 연산자의 결과 값은 TRUE가 된다.

```SQL
SELECT *
FROM EMP
WHERE NOT SAL = 3000;
```

복잡한 여러 개 조건식이 AND, OR로 묶여 있는 상태에서 정반대 결과를 얻고자 할 때에는 유용하게 사용할 수 있다. 복잡한 조건식에서 정반대의 최종 결과를 원할 때, 조건식을 일일이 수정하여 작성하는 것보다 NOT 연산자로 한 번에 뒤집에서 사용하는 것이 간편하고 SQL문 작성 시간도 줄일 수 있다. 

```SQL
SELECT *
FROM EMP
WHERE NOT (DEPTNO = 10 AND JOB = 'MANAGER');
```

### IN 연산자

= 기호는 WHERE 조건식에서 특정 열 데이터 값만을 조회하고자 할 때 사용한다. 앞에서 살펴본 예제에서 급여 열이 3000인 사원, 직업 열이 CLERK인 사원, 부서 번호 열이 30인 사원 등으로 조회한 SELECT문이 이에 해당한다. 만약 지금까지 배운 연산자를 사용하여 직책 열이 SALESMAN이거나 MANAGER 또는 CLERK 중 하나인 데이터를 조회하려면 다음과 같이 논리 연산자 OR를 사용해서 출력할 수 있다.

```SQL
SELECT *
FROM EMP
WHERE JOB = 'MANAGER'
   OR JOB = 'SALESMAN'
   OR JOB = 'CLERK';
```

출력하고 싶은 열의 조건이 여러 가지일 때 OR 연산자로 여러 조건식을 묶어 주는 것도 하나의 방법이지만, 조건이 늘어날수록 조건식을 많이 작성해야 하기 때문에 조금 번거롭다.

이때 IN 연산자를 사용하면 특정 열에 해당하는 조건을 여러 개 지정할 수 있다. IN 연산자의 기본 형식은 다음과 같다.

```SQL
SELECT [조회할 열1 이름], [열2 이름], [열N 이름]
FROM [조회할 테이블 이름]
WHERE 열 이름 IN (데이터1, 데이터2, ..., 데이터N);
```

| 키워드 | 필수 요소                       | 선택 요소 | 설명                                             |
| ------ | ------------------------------- | --------- | ------------------------------------------------ |
| IN     | 열 이름 조회할 열의 데이터 목록 |           | 특정 열에 포함된 데이터를 여러 개 조회할 때 사용 |

```SQL
SELECT *
FROM EMP
WHERE JOB IN ('MANAGER', 'SALESMAN', 'CLERK');
```

```SQL
SELECT *
FROM EMP
WHERE JOB NOT IN ('MANAGER', 'SALESMAN', 'CLERK');
```

### BETWEEM A AND B 연산자

```SQL
SELECT [조회할 열1 이름], ... , [열N 이름]
FROM [조회할 테이블 이름]
WHERE 열 이름 BETWEEN 최솟값 AND 최댓값;
```

| 키워드          | 필수 요소               | 선택 요소 | 설명                                   |
| --------------- | ----------------------- | --------- | -------------------------------------- |
| BETWEEN A AND B | 열 이름, 최솟값, 최댓값 |           | 일정 범위 내의 데이터를 조회할 때 사용 |

```SQL
SELECT *
FROM EMP
WHERE SAL BETWEEN 2000 AND 3000;
```

```SQL
SELECT *
FROM EMP
WHERE SAL NOT BETWEEN 2000 AND 3000;
```

### LIKE 연산자와 와일드 카드

LIKE 연산자는 이메일이나 게시판 제목 또는 내용 검색 기능처럼 일부 문자열이 포함된 데이터를 조회할 때 사용한다.

```SQL
SELECT *
FROM EMP
WHERE ENAME LIKE 'S%';
```

와일드 카드는 특정 문자 또는 문자열을 대체하거나 문자열 데이터의 패턴을 표기하는 특수 문자이다. LIKE 연산자와 함께 사용할 수 있는 와일드 카드는 _와 %이다.

| 종류 | 의미                                                         |
| ---- | ------------------------------------------------------------ |
| _    | 어떤 값이든 상관없이 한 개의 문자 데이터를 의미              |
| %    | 길이와 상관없이(문자 없는 경우도 포함) 모든 문자 데이터를 의미 |

```SQL
SELECT *
FROM EMP
WHERE ENAME LIKE '_L%';
```

```sql
SELECT *
FROM EMP
WHERE ENAME LIKE '%AM%';
```

```SQL
SELECT *
FROM EMP
WHERE ENAME NOT LIKE '%AM%';
```

**와일드 카드 문자가 데이터 일부일 경우**

```SQL
SELECT *
FROM SOME_TABLE
WHERE SOME_COLUMN LIKE 'A\_A%' ESCAPE '\';
```

`A\_A%`에서 `\` 문자 바로 뒤에 있는 _는 와일드 카드 기호로서가 아닌 데이터에 포함된 문자로 인식하라는 의미이다. ESCAPE 문자 `\`는 ESCAPE절에서 지정할 수 있다. 그리고 `\` 외 다른 문자도 지정하여 사용할 수 있다.

**LIKE 연산자와 와일드 카드 문자의 성능**

LIKE 연산자와 와일드 카드를 사용한 SELECT문은 사용하기 간편하고 기능 면에서 활용도가 높지만 데이터 조회 성능과 관련된 의견은 다양하다. 실무에서는 행 수가 상당한 테이블을 여러 개 조합하여 데이터를 조회하는 경우가 많다. 데이터 조회 속도는 제공하려는 서비스 질과 직접적으로 연관되는 일이 빈번하기 때문에 데이터 조회 속도는 매우 중요하다. 

LIKE 연산자와 와일드 카드를 활용한 SELECT문은 와일드 카드를 어떻게 사용하느냐에 따라 데이터를 조회해 오는 시간에 차이가 난다고 알려져 있다. 

### IS NULL 연산자

NULL은 데이터 값이 완전히 '비어 있는' 상태를 말한다. 숫자 0은 값 0이 존재한다는 뜻이므로 NULL과 혼동하지 않도록 주의해야 한다. NULL의 의미를 예를 들어 설명하면 다음과 같다.

```SQL
SELECT ENAME, SAL, SAL*12+COMM AS ANNSAL, COMM
FROM EMP;
```

| 의미               | 예                                                          |
| ------------------ | ----------------------------------------------------------- |
| 값이 존재하지 않음 | 통장을 개설한 적 없는 은행 고객의 계좌 번호                 |
| 해당 사항 없음     | 미혼인 고객의 결혼기념일                                    |
| 노출할 수 없는 값  | 고객 비밀번호 찾기 같은 열람을 제한해야 하는 특정 개인 정보 |
| 확정되지 않은 값   | 미성년자의 출신 대학                                        |

따라서 NULL은 '현재' 무슨 값인지 확정되지 않은 상태'이거나 '값 자체가 존재하지 않는 상태'를 나타내는 데이터에 사용한다. 이 때문에 앞에서 살펴본 연산자는 대부분 연산 대상이 NULL일 때 연산 자체가 무의미해지는 현상이 발생한다.

```SQL
SELECT *
FROM EMP
WHERE COMM = NULL;
```

```SQL
SELECT *
FROM EMP
WHERE COMM IS NULL;
```

```SQL
SELECT *
FROM EMP
WHERE MGR IS NOT NULL;
```

```SQL
SELECT *
FROM EMP
WHERE SAL > NULL
AND COMM IS NULL;
```

```SQL
SELECT *
FROM EMP
WHERE SAL > NULL
OR COMM IS NULL;
```

**AND 연산 및 결과**

|           | true  | false | NULL  |
| --------- | ----- | ----- | ----- |
| **true**  | true  | false | NULL  |
| **false** | false | false | false |
| **NULL**  | NULL  | false | NULL  |

**OR 연산 및 결과**

|           | true | false | NULL |
| --------- | ---- | ----- | ---- |
| **true**  | true | true  | true |
| **false** | true | false | NULL |
| **NULL**  | true | NULL  | NULL |

### 집합 연산자

관계형 데이터베이스 개념은 집합론에서 시작되었다. SQL문에서는 SELECT문을 통해 데이터를 조회한 결과를 하나의 집합과 같이 다룰 수 있는 집합 연산자를 사용할 수 있다. 그리고 두 개 이상의 SELECT문의 결과 값을 연결할 때 사용한다.

```SQL
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10
UNION
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 20;
```

```
7782	CLARK	2450	10
7839	KING	5000	10
7934	MILLER	1300	10
7369	SMITH	800	20
7566	JONES	2975	20
7902	FORD	3000	20
```

여기서 주의할 점은 집합 연산자로 두 개의 SELECT문의 결과 값을 연결할 때 각 SELECT문이 출력하려는 열 개수와 각 열의 자료형이 순서별로 일치해야 한다는 것이다. 예를 들어 다음의 집합 연산자를 사용한 두 SELECT문은 모두 실행되지 않는다. 

```SQL
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10
UNION
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE DEPTNO = 20;
```

```
ORA-01789: 질의 블록은 부정확한 수의 결과 열을 가지고 있습니다.
```

```SQL
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10
UNION
SELECT ENAME, EMPNO, DEPTNO, SAL
FROM EMP
WHERE DEPTNO = 20;
```

```
ORA-01790: 대응하는 식과 같은 데이터 유형이어야 합니다
```

만약 연결하려는 두 SELECT문의 열 개수와 자료형이 같다면 서로 다른 테이블에서 조회하거나 조회하는 열 이름이 다른 것은 문제가 되지 않는다. 다소 이상해보이는 결과가 나오겠지만 집합 연산자를 다음과 같이 사용할 수도 있다.

```SQL
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10
UNION
SELECT SAL, JOB, DEPTNO, SAL
FROM EMP
WHERE DEPTNO = 20;
```

```
800	    CLERK	20	800
2975	MANAGER	20	2975
3000	ANALYST	20	3000
7782	CLARK	2450	10
7839	KING	5000	10
7934	MILLER	1300	10
```

EMPNO와 SAL 열은 다른 열이지만 양쪽 다 숫자가 저장된 데이터이기 때문에 문제없이 연결되고 있다. 다른 열도 마찬가지이다. 다만 최종 출력되는 열 이름은 먼저 작성한 SELECT문의 열 이름으로 표기된다는 것에 주의해야 한다.

오라클 데이터베이스에서 사용하는 집합 연산자는 다음과 같이 4가지 종류가 있다.

| 종류      | 설명                                                         |
| --------- | ------------------------------------------------------------ |
| UNION     | 연결된 SELECT문의 결과 값을 합집합으로 묶어준다. 결과 값의 중복은 제거된다. |
| UNION ALL | 연결된 SELECT문의 결과 값을 합집합으로 묶어 준다. 중복된 결과 값도 제거 없이 모두 출력된다. |
| MINUS     | 먼저 작성한 SELECT문의 결과 값에서 다음 SELECT문의 결과 값을 차집합 처리한다. 먼저 작성한 SELECT문의 결과 값 중 다음 SELECT문에 존재하지 않는 데이터만 출력된다. |
| INTERSECT | 먼저 작성한 SELECT문과 다음 SELECT문의 결과 값이 같은 데이터만 출력된다. 교집합과 같은 의미이다. |

```SQL
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10
UNION
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10;
```

```
7782	CLARK	2450	10
7839	KING	5000	10
7934	MILLER	1300	10
```

```SQL
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10
UNION ALL
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10;
```

```
7782	CLARK	2450	10
7839	KING	5000	10
7934	MILLER	1300	10
7782	CLARK	2450	10
7839	KING	5000	10
7934	MILLER	1300	10
```

UNION은 데이터 중복을 제거한 상태로 결과 값을 출력하고 UNION ALL은 중복 데이터도 모두 출력한다. 둘 다 합집합을 의미하는 연산자이지만 결과 값이 달라지므로 사용할 때 주의해야 한다.

MINUS 연산자는 차집합을 의미한다. 다음과 같이 두 SELECT문을 MINUS 연산자로 묶어 주면 두 SELECT문의 결과 값이 같은 데이터는 제외하고 첫 번째 SELECT문의 결과 값이 출력된다.

```SQL
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
MINUS
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10;
```

```
7369	SMITH	800	20
7499	ALLEN	1600	30
7521	WARD	1250	30
7566	JONES	2975	20
7654	MARTIN	1250	30
7698	BLAKE	2850	30
7844	TURNER	1500	30
7900	JAMES	950	    30
7902	FORD	3000	20
```

EMP 테이블 전체 행을 조회한 첫 번째 SELECT문의 결과에서 10번 부서에 있는 사원 데이터를 제외한 결과 값이 출력된다.

INTERSECT 연산자는 교집합을 의미하므로 두 SELECT문의 결과 값이 같은 데이터만 출력된다.

```SQL
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
INTERSECT
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10;
```

```
7782	CLARK	2450	10
7839	KING	5000	10
7934	MILLER	1300	10
```

### 연산자 우선순의

| 우선순위 | 연산자                              | 설명                       |
| -------- | ----------------------------------- | -------------------------- |
| 높음     | *, /                                | 산술 연산자 곱하기, 나누기 |
|          | +, -                                | 산술 연산자 더하기, 빼기   |
|          | =, !=, ^=, <>, >, >=, <, <=         | 대소 비교 연산자           |
|          | IS (NOT) NULL, (NOT) LIKE, (NOT) IN | (그 외) 비교 연산자        |
|          | BETWEEN A AND B                     | BETWEEN 연산               |
|          | NOT                                 | 논리 부정 연산자 NOT       |
|          | AND                                 | 논리 연산자 AND            |
| 낮음     | OR                                  | 논리 연산자 OR             |

연산식을 소괄호( )로 묶어 주면 연산자의 기본 우선순위와는 별개로 괄호 안의 연산식을 먼저 수행한다.

# 데이터 처리와 가공을 위한 오라클 함수

## 오라클 함수

### 오라클 함수의 종류

오라클 함수는 함수를 제작한 주체를 기준으로 오라클에서 기본으로 제공하고 있는 내장 함수(built-in function)와 사용자가 필요에 의해 직접 정의한 사용자 정의 함수(user-defined function)로 나뉜다.

### 내장 함수의 종류

내장 함수는 입력 방식에 따라 데이터 처리에 사용하는 행이 나뉜다. 데이터가 한 행씩 입력되고 입력된 한 행당 결과가 하나씩 나오는 단일행 함수(single-row function)라고 한다. 

| 열1  | 열2  | ...  | 열N  |
| ---- | ---- | ---- | ---- |
| 행1  |      |      |      |
| 행2  |      |      |      |
| ...  |      |      |      |
| 행3  |      |      |      |

▼▼▼

| 열1  | 열2  | ...  | 열N  |
| ---- | ---- | ---- | ---- |
| 행1  |      |      |      |
| 행2  |      |      |      |
| ...  |      |      |      |
| 행3  |      |      |      |

반면에 여러 행이 입력되어 하나의 행으로 결과가 반환되는 함수를 다중행 함수(multiple-row function)라고 한다. 단일행 함수와 다중행 함수는 다루는 자료형에 따라 조금 더 세분화된다. 

| 열1  | 열2  | ...  | 열N  |
| ---- | ---- | ---- | ---- |
| 행1  |      |      |      |
| 행2  |      |      |      |
| ...  |      |      |      |
| 행3  |      |      |      |

▼▼▼

| 열1  | 열2  | ...  | 열N  |
| ---- | ---- | ---- | ---- |
| 행1  |      |      |      |

## 문자 함수

문자 데이터를 가공하거나 문자 데이터로부터 특정 결과를 얻고자 할 때 사용하는 함수이다. 실무에서 자주 사용하는 데이터는 문자, 숫자, 날짜 데이터이다. 

### UPPER, LOWER, INITCAP 함수

| 함수            | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| UPPER(문자열)   | 괄호 안 문자 데이터를 모두 대문자로 변환하여 반환            |
| LOWER(문자열)   | 괄호 안 문자 데이터를 모두 소문자로 변환하여 반환            |
| INITCAT(문자열) | 괄호 안 문자 데이터 중 첫 글자는 대문자로, 나머지 문자를 소문자로 변환 후 반환 |

```SQL
SELECT ENAME, UPPER(ENAME), LOWER(ENAME), INITCAP(ENAME)
FROM EMP;
```

```SQL
SELECT *
FROM 게시판테이블
WHERE 게시판 제목 열 LIKE '%Oracle%'
OR    게시판 본문 열 LIKE '%Oracle%';
```

LIKE 연산자를 사용하여 문자열 데이터의 패턴을 %Oracle%로 지정하였기 때문에 'Oracle' 문자열이 포함된 데이터가 모두 출력된다. 하지만 이 조건식에서 사용하는 문자열 데이터 패턴은 ORACLE, oracle, OrAcLe과 같이 대소문자가 다른 여러 가지 경우의 'Oracle' 단어를 찾아내지 못한다.

이때 조건식 양쪽 항목의 문자열 데이터를 모두 대문자나 소문자로 바꿔서 비교한다면 실제 검색어의 대소문자 여부와 상관없이 검색 단어와 일치한 문자열을 포함한 데이터를 찾을 수 있다. 예를 들어 EMP 테이블에서 사원 이름이 대소문자 상관없이 scott인 사람을 찾으려면 다음과 같이 문자 함수를 사용하면 된다.

```sql
SELECT *
FROM EMP
WHERE UPPER(ENAME) = UPPER('king');
```

```SQL
SELECT *
FROM EMP
WHERE UPPER(ENAME) LIKE UPPER('%king%');
```

```
7839	KING	PRESIDENT   (null)   81/11/17	5000   (null)   10
```

### LENGTH 함수

```SQL
SELECT ENAME, LENGTH(ENAME)
FROM EMP;
```

```
SMITH	5
ALLEN	5
WARD	4
JONES	5
MARTIN	6
BLAKE	5
CLARK	5
KING	4
TURNER	6
JAMES	5
FORD	4
MILLER	6
```

```SQL
SELECT ENAME, LENGTH(ENAME)
FROM EMP
WHERE LENGTH(ENAME) >= 5;
```

```
SMITH	5
ALLEN	5
JONES	5
MARTIN	6
BLAKE	5
CLARK	5
TURNER	6
JAMES	5
MILLER	6
```

**LENGTH 함수와 LENGTHB 함수 비교하기**

```sql
SELECT LENGTH('한글'), LENGTHB('한글')
FROM DUAL;
```

```
2	6
```

원래는 2, 4의 결과가 나와야 하지만 문자 인코딩을 UTF-8을 사용하고 있으므로 2, 6으로 나온다.

**DUAL 테이블은 어떤 테이블인가?**

> DUAL 테이블은 오라클의 최고 권한 관리자 계정인 SYS 소유의 테이블로 SCOTT 계정도 사용할 수 있는 더미(dummy) 테이블이다. 데이터 저장 공간이 아닌 임시 연산이나 결과 값 확인 용도로 종종 사용된다. 앞으로도 특정 연산 또는 함수의 단일 결과만을 확인할 때 사용한다.

### SUBSTR 함수

주민등록번호 중 생년월일 앞자리만 필요하거나 전화버노의 마지막 네 자리 숫자만 추출하는 경우와 같이 문자열 중 일부를 추출할 때 SUBSTR 함수를 사용한다.

| 함수                                        | 설명                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| SUBSTR(문자열 데이터, 시작 위치, 추출 길이) | 문자열 데이터의 시작 위치부터 추출 길이만큼 추출한다. 시작 위치가 음수일 경우에는 마지막 위치부터 거슬러 올라간 위치에서 시작한다. |
| SUBSTR(문자열 데이터, 시작 위치)            | 문자열 데이터의 시작 위치부터 문자열 데이터 끝까지 추출한다. 시작 위치가 음수일 경우에는 마지막 위치부터 거슬러 올라간 위치에서 끝까지 추출한다. |

**SUBSTR 함수 사용하기**

```SQL
SELECT JOB, SUBSTR(JOB, 1, 2), SUBSTR(JOB, 3, 2), SUBSTR(JOB, 5)
FROM EMP;
```

```
CLERK	    CL	ER	K
SALESMAN	SA	LE	SMAN
SALESMAN	SA	LE	SMAN
MANAGER	    MA	NA	GER
SALESMAN	SA	LE	SMAN
MANAGER	    MA	NA	GER
MANAGER	    MA	NA	GER
PRESIDENT	PR	ES	IDENT
SALESMAN	SA	LE	SMAN
CLERK	    CL	ER	K
ANALYST	    AN	AL	YST
CLERK	    CL	ER	K
```

* SUBSTR(JOB, 1, 2) 의미

  첫 번째 글자부터 두 글자 출력

* SUBSTR(JOB, 3, 2) 의미

  세 번째 글자부터 두 글자 출력

* SUBSTR(JOB, 5) 의미

  다섯 번째 글자부터 끝까지 출력

**SUBSTR 함수와 다른 함수(LENGTH) 함께 사용하기**

```SQL
SELECT JOB,
	   SUBSTR(JOB, -LENGTH(JOB)),
	   SUBSTR(JOB, -LENGTH(JOB), 2),
	   SUBSTR(JOB, -3)
FROM EMP;
```

```
CLERK	    CLERK	    CL	ERK
SALESMAN	SALESMAN	SA	MAN
SALESMAN	SALESMAN	SA	MAN
MANAGER	    MANAGER	    MA	GER
SALESMAN	SALESMAN	SA	MAN
MANAGER	    MANAGER	    MA	GER
MANAGER	    MANAGER  	MA	GER
PRESIDENT	PRESIDENT	PR	ENT
SALESMAN	SALESMAN	SA	MAN
CLERK	    CLERK	    CL	ERK
ANALYST	    ANALYST	    AN	YST
CLERK	    CLERK	    CL	ERK
```

* SUBSTR(JOB, -LENGTH(JOB))

  **CLERT**

  -5자리(CLERK의 -LENGTH(JOB))부터 끝까지 출력

* SUBSTR(JOB, -LENGTH(JOB), 2)

  **CLERK**

  -5자리(CLERK의 -LENGTH(JOB))부터 두 글자 출력

* SUBSTR(JOB, -3)

  **CLERK**

  -3자리(CLERK의 -LENGTH(JOB))부터 끝까지 출력

### INSTR 함수

문자열 데이터 안에 특정 문자나 문자열이 어디에 포함되어 있는지를 알고자 할 때 INSTR 함수를 사용한다. INSTR 함수는 총 네 개의 입력 값을 지정할 수 있으며 최소 두 개의 입력값, 즉 원본 문자열 데이터와 원본 문자열 데이터에서 찾으려는 문자 이렇게 두 가지는 반드시 지정해 주어야 한다.

```SQL
INSTR([대상 문자열 데이터(필수)]
      [위치를 찾으려는 부분 문자(필수)],
      [위치 찾기를 시작할 대상 문자열 데이터 위치(선택, 기본값은 1)],
      [시작 위치에서 찾으려는 문자가 몇 번째인지 지정(선택, 기본값은 1)])
```

**특정 문자 위치 찾기**

```SQL
SELECT INSTR('HELLO, ORACLE!', 'L') AS INSTR_1,
	   INSTR('HELLO, ORACLE!', 'L', 5) AS INSTR_2,
	   INSTR('HELLO, ORACLE!', 'L', 2, 2) AS INSTR_3
FROM DUAL;
```

```
3	12	4
```

* INSTR('HELLO, ORACLE', 'L')

  시작 위치와 몇 번째 L인지 정해지지 않으므로 처음부터 검색

  | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | H    | E    | L    | L    | O    | ,    |      | O    | R    | A    | C    | L    | E    | !    |
  |      |      | 찾음 |      |      |      |      |      |      |      |      |      |      |      |

* INSTR('HELLO, ORACLE!', 'L', 5)

  다섯 번째 글자 O부터 L을 찾음

  | 1    | 2    | 3    | 4    | 5               | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   |
  | ---- | ---- | ---- | ---- | --------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | H    | E    | L    | L    | O               | ,    |      | O    | R    | A    | C    | L    | E    | !    |
  |      |      |      |      | 여기서부터 검색 |      |      |      |      |      |      | 찾음 |      |      |

* INSTR('HELLO, ORACLE!', 'L', 2, 2)

  두 번째 글자 E부터 시작해서 두 번째 L을 찾음

  | 1    | 2               | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   |
  | ---- | --------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | H    | E               | L    | L    | O    | ,    |      | O    | R    | A    | C    | L    | E    | !    |
  |      | 여기서부터 검색 |      | 찾음 |      |      |      |      |      |      |      |      |      |      |

INSTR_1은 필수 입력 데이터 두 개만 입력했다. 'HELLO, ORACLE!' 문자열 데이터에서 L 위치를 찾으라는 뜻이다. 시작 위치와 몇 번째 L을 찾을지 지정하지 않았기 때문에 문자열 데이터의 처음부터 왼쪽에서 오른쪽 방향으로 L을 찾게 된다. L이 세 번째 문자에서 가장 먼저 발견되므로 실행 결과로 3이 출력된다.

INSTR_2는 세 번째 항목에 5를 작성했으므로 'HELLO, ORACLE!' 문자열에서 다섯 번째 글자인 O 위치부터 L을 찾게 된다. 따라서 맨 마지막 L이 있는 위치인 12가 출력되는 것이다.

INSTR_3은 두 번째 글자 E부터 L을 찾되 두 번째로 찾은 L의 위치를 반환하라고 지정했으므로 4가 출력된다.

INSTR 함수의 세 번째 입력 데이터, 즉 위치 찾기를 시작하는 위치 값에 음수를 쓸 때 원본 문자열 데이터의 오른쪽 끝부터 왼쪽 방향으로 검색한다. 만약 찾으려는 문자가 문자열 데이터에 포함되어 있지 않다면 위치 값이 없으므로 0을 반환한다. 따라서 INSTR 함수를 LIKE 와 비슷한 용도로 사용할 수도 있다. 예를 들어 사원 이름에 S가 포함된 사원을 출력하고 싶다면 LIKE 연산자나 INSTR 함수를 WHERE절에 다음과 같이 적용하기도 한다.

**특정 문자를 포함하고 있는 행 찾기**

```SQL
SELECT *
FROM EMP
WHERE INSTR(ENAME, 'S') > 0;
```

```
7369	SMITH	CLERK	7902	80/12/17	800		20
7566	JONES	MANAGER	7839	81/04/02	2975    20
7900	JAMES	CLERK	7698	81/12/03	950		30
```

위 예제의 WHERE절에 있는 INSTR 함수의 결과 값이 0보다 크다면 사원 이름에 S가 존재한다는 의미이다.

```SQL
SELECT *
FROM EMP
WHERE ENAME LIKE '%S%'
```

```
7369	SMITH	CLERK	7902	80/12/17	800   (NULL)  20
7566	JONES	MANAGER	7839	81/04/02	2975  (NULL)  20
7900	JAMES	CLERK	7698	81/12/03	950	  (NULL)  30
```

위 예제의 LIKE 연산자를 사용하여 사원 이름 열의 패턴이 %S%인 문자열을 찾는 것과 같은 효과를 볼 수 있다.

### 특정 문자를 다른 문자로 바꾸는 REPLACE 함수

REPLACE 함수는 특정 문자열 데이터에 포함된 문자를 다른 문자로 대체할 경우에 유용한 함수이다.

```SQL 
REPLACE([문자열 데이터 또는 열 이름(필수)], [찾는 문자(필수)], [대체할 문자(선택)])
```

만약 대체할 문자를 입력하지 않는다면 찾는 문자로 지정한 문자는 문자열 데이터에서 삭제된다.

```SQL
SELECT '010-1234-5678' AS REPLACE_BEFORE,
		REPLACE('010-1234-5678', '-', ' ') AS REPLACE_1,
		REPLACE('010-1234-5678', '-') AS REPLACE_2
FROM DUAL;
```

```
010-1234-5678	010 1234 5678	01012345678
```

### 두 문자열 데이터를 합치는 CONCAT 함수

CONCAT 함수는 두 개의 문자열 데이터를 하나의 데이터로 연결해 주는 역할을 한다. 두 개의 입력 데이터 지정을 하고 열이나 문자열 데이터 모두 지정할 수 있다. 

```SQL
SELECT CONCAT(EMPNO, ENAME),
	   CONCAT(EMPNO, CONCAT(' : ', ENAME))
FROM EMP
WHERE ENAME = 'SCOTT';
```

```
7839KING	7839 : KING
```

**문자열 데이터를 연결하는 || 연산자**

|| 연산자는 CONCAT 함수와 유사하게 열이나 문자열을 연결한다. 

```SQL
SELECT EMPNO || ENAME,
	   EMPNO || ' : ' || ENAME
FROM EMP;
```

```
7369SMITH	7369 : SMITH
7499ALLEN	7499 : ALLEN
7521WARD	7521 : WARD
7566JONES	7566 : JONES
7654MARTIN	7654 : MARTIN
7698BLAKE	7698 : BLAKE
7782CLARK	7782 : CLARK
7839KING	7839 : KING
7844TURNER	7844 : TURNER
7900JAMES	7900 : JAMES
7902FORD	7902 : FORD
7934MILLER	7934 : MILLER
```

### TRIM, LTRIM, RTRIM 함수

TRIM, LTRIM, RTRIM 함수는 문자열 데이터 내에서 특정 문자를 지우기 위해 사용한다. 원본 문자열 데이터를 제외한 나머지 데이터는 모두 생략할 수 있다. 삭제할 문자가 생략될 경우에 기본적으로 공백을 제거한다. 그리고 삭제 옵션은 왼쪽에 있는 글자를 지우는 LEADING, 오른쪽에 있는 글자를 지우는 TRAILING, 양쪽의 글자를 모두 지우는 BOTH를 사용한다.

**TRIM 함수의 기본 사용법**

```SQL
TRIM([삭제 옵션(선택)] [삭제할 문자(선택)] FROM [원본 문자열 데이터(필수)])
```

TRIM 함수의 삭제할 문자는 필수가 아니므로 지정하지 않아도 된다. 삭제할 문자가 없으면 공백이 제거된다.

**TRIM 함수 사용하기(삭제할 문자가 없을 때)**

```SQL
SELECT '[' || TRIM(' __Oracle__ ') || ']' AS TRIM,
	   '[' || TRIM(LEADING FROM ' __Oracle__ ') || ']' AS TRIM_LEADING,
	   '[' || TRIM(TRAILING FROM ' __Oracle__ ') || ']' AS TRIM_TRAILING,
	   '[' || TRIM(BOTH FROM ' __Oracle__ ') || ']' AS TRIM_BOTH
FROM DUAL;
```

```
[__Oracle__]	[__Oracle__ ]	[ __Oracle__]	[__Oracle__]
```

**TRIM 함수 사용하기(삭제할 문자가 있을 때)**

```SQL
SELECT '[' || TRIM('_' FROM '__Oracle__') || ']' AS TRIM,
	   '[' || TRIM(LEADING '_' FROM '__Oracle__') || ']' AS TRIM_LEADING,
	   '[' || TRIM(TRAILING '_' FROM '__Oracle__') || ']' AS TRIM_TRAILING,
	   '[' || TRIM(BOTH '_' FROM '__Oracle__') || ']' AS TRIM_BOTH
FROM DUAL;
```

```
[Oracle]	[Oracle__]	[__Oracle]	[Oracle]
```

**LTRIM, RTRIM 함수의 기본 사용법**

LTRIM, RTRIM 함수는 각각 왼쪽, 오른쪽의 지정 문자를 삭제하는 데 사용한다. TRIM과 마찬가지로 삭제할 문자를 지정하지 않을 경우 공백 문자가 삭제된다. TRIM 함수와 다른 점은 삭제할 문자를 하나만 지정하는 것이 아니라 여러 문자 지정이 가능하다는 것이다.

```SQL
LTRIM([원본 문자열 데이터(필수)], [삭제할 문자 집합(선택)])
RTRIM([원본 문자열 데이터(필수)], [삭제할 문자 집합(선택)])
```

| 함수  | 설명                                                         |
| ----- | ------------------------------------------------------------ |
| LTRIM | 원본 문자열의 왼쪽에서 삭제할 문자열을 지정한다(삭제할 문자열을 지정하지 않으면 공백이 삭제됨). |
| RTRIM | 원본 문자열의 오른쪽에서 삭제할 문자열을 지정한다(삭제할 문자열을 지정하지 않으면 공백이 삭제됨). |

```SQL
SELECT '[' || TRIM(' _Oracle_ ') || ']' AS TRIM,
	   '[' || LTRIM(' _Oracle_ ') || ']' AS LTRIM,
	   '[' || LTRIM('<_Oracle_>', '_<') || ']' AS LTRIM_2,
	   '[' || RTRIM(' _Oracle_ ') || ']' AS RTRIM,
	   '[' || RTRIM('<_Oracle_>', '>_') || ']' AS RTRIM_2
FROM DUAL;
```

```
[_Oracle_]	[_Oracle_ ]	[Oracle_>]	[ _Oracle_]	[<_Oracle]
```

삭제할 문자를 지정하지 않을 경우 각각 함수 종류(TRIM, LTRIM, RTRIM)에 따라 양쪽, 왼쪽, 오른쪽 공백이 제거된다. LTRIM, RTRIM을 사용한 예시에서 삭제 대상이 문자일 경우 해당 문자의 순서와 반복을 통해 만들어 낼 수 있는 모든 조합이 각각 왼쪽, 오른쪽부터 삭제되어 간다. LTRIM_2의 경우 `<_` 문자열이 `_`, `<` 문자의 조합으로 표현 가능한 문자이므로 삭제된다. 하지만 그 다음에 이어지는 Oracle의 O문자에서(RTRIM_2의 경우 e) `_<`로 조합할 수 없는 문자가 시작되므로 이 단계에서 LTRIM을 통한 삭제 작업은 끝나게 된다. 즉 `_<`를 삭제할 문자로 지정하고 원본 문자열이 `<_<_Oracle`일 경우 결과는 Oracle만 남게 된다. 하지만 `<_O<_racle` 문자열은 LTRIM의 결과로 `O<_racle`이 남게 된다.

**LTRIM, RTRIM, TRIM 옵션까지 모두 다 외워야 하나요?**

>문자 삭제를 위한 TRIM, LTRIM, RTRIM 함수는 사용하는 옵션이 많아 까다로워 보일 수 있다. 만약 옵션을 모두 외우기가 어렵다면 우선 LTRIM, RTRIM 함수가 존재하고 있다는 것과 TRIM 함수는 경우에 따라서 문자열 데이터 양쪽의 공백을 제거할 때 사용한다.
>
>보통 실무에서 TRIM 함수는 검색 기준이 되는 데이터에 혹시나 들어 있을지도 모르는 양쪽 끝의 공백을 제거할 때 많이 사용한다. 예를 들어 유저가 로그인을 하려고 아이디를 입력했을 때 사용자 실수로 스페이스바가 눌러져 공백이 함께 입력되는 경우이다.

## 숫자 함수

## 날짜 함수

## 형 변환 함수

## NULL 처리 함수

## DECODE 함수와 CASE문

# 다중행 함수와 데이터 그룹화

## 다중행 함수

## GROUP BY절

## HAVING절

## 그룹화와 관련된 여러 함수

# 조인

## 조인

## 조인 종류

## SQL-99 표준 문법으로 배우는 조인

# 서브쿼리

## 서브쿼리

## 실행 결과가 하나인 단일행 서브쿼리

## 실행 결과가 여러 개인 다중행 서브쿼리

## 비교할 열이 여러 개인 다중열 서브쿼리

## FROM절에 사용하는 서브쿼리와 WITH절

## SELECT절에 사용하는 서브쿼리

# 데이터 조작어(추가, 수정, 삭제)

## 데이터 추가

## 데이터 수정

## 데이터 삭제

# 트랜잭션 제어와 세션

## 트랜잭션

## 트랜잭션 제어 명령어

## 세션과 읽기 일관성의 의미

## 수정 중인 데이터 접근을 막는 LOCK

# 데이터 정의어

## 객체를 생성, 변경, 삭제하는 데이터 정의어

## CREATE

## ALTER

## RENAME

## TRUNCATE

## DROP

# 객체 종류

## 데이터 사전

## 인덱스

## 뷰

## 시퀀스

## 공식 별칭을 지정하는 동의어

# 제약 조건

## 제약 조건 종류

## NOT NULL

## UNIQUE

## PRIMARY KEY

## FOREIGN KEY

## CHECK

## DEFAULT

# 사용자, 권한, 롤 관리

## 사용자 관리

## 권한 관리

## 롤 관리

# PL/SQL 기초

## PL/SQL 구조

## 변수와 상수

## 조건 제어문

## 반복 제어문

# 레코드와 컬렉션

## 레코드

## 컬렉션

# 커서와 예외 처리

## 커서

## 예외 처리

# 저장 서브프로그램

## 저장 서브프로그램

## 프로시저

## 함수

## 패키지

## 트리거